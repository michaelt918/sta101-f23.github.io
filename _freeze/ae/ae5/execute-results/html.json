{
  "hash": "434b98a71fc32939ae1cde6212cea9fa",
  "result": {
    "markdown": "---\ntitle: \"EDA III: Joins\"\nsubtitle: \"STA 101\"\nformat: html\n---\n\n\n## Bulletin\n\n- [Lab 02](https://sta101-fa22.netlify.app/static/labs/lab02.html) due Thursday\n\n## Today\n\nBy the end of today you will...\n\n- join data frames\n\n## Getting started\n\nDownload this application exercise by pasting the code below into your **console** (bottom left of screen)\n\n    download.file(\"https://sta101-fa22.netlify.app/static/appex/ae5.qmd\",\n      destfile = \"ae5.qmd\")\n\n## Load packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n## Joins\n\nThere are six join functions in the `dplyr` package. Join functions take two data frames as arguments and return a data frame.\n\nThe six joins can be broken down into two categories:\n\n- **Mutating joins**: joining data frames results in mutating new columns\n- **Filtering joins**: joining data frames results in filtering observations in one data frame based on another.\n\nIn all of the following examples, `x` and `y` are two data frames:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = tibble(value = c(100, 200, 300),\n            xcol = c(\"x1\", \"x2\", \"x3\"))\ny = tibble(value = c(100, 200, 400),\n            ycol = c(\"y1\", \"y2\", \"y4\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  value xcol \n  <dbl> <chr>\n1   100 x1   \n2   200 x2   \n3   300 x3   \n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  value ycol \n  <dbl> <chr>\n1   100 y1   \n2   200 y2   \n3   400 y4   \n```\n:::\n:::\n\n\n\n\n### Mutating joins\n\nThe most popular 2 joins:\n\n- `left_join(x, y)`: keep all rows from `x` and adds columns from `y`\n- `right_join(x, y)`: keeps all rows from `y` and adds columns from `x`\n\nTwo more helpful joins:\n\n- `inner_join(x, y)`: join all rows from `x` where there are matching values in `y`.Returns all combinations in case of multiple matches\n- `full_join(x, y)`: include all rows in `x` or `y`\n\nToy examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>%\n  left_join(y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(value)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1   100 x1    y1   \n2   200 x2    y2   \n3   300 x3    <NA> \n```\n:::\n:::\n\n\n- What do you think `Joining, by = \"value\"` means?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>%\n  right_join(y, by = \"value\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1   100 x1    y1   \n2   200 x2    y2   \n3   400 <NA>  y4   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>%\n  inner_join(y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(value)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1   100 x1    y1   \n2   200 x2    y2   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(value)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n  value xcol  ycol \n  <dbl> <chr> <chr>\n1   100 x1    y1   \n2   200 x2    y2   \n3   300 x3    <NA> \n4   400 <NA>  y4   \n```\n:::\n:::\n\n\n\n### Filtering joins\n\n- `semi_join(x, y)`: return all rows from `x` with match in `y`\n- `anti_join(x, y)`: return all rows from `x` without a match in `y`\n\nIn both of these \"filtering\" cases we do **not** add any new columns to our first argument (the data frame `x`).\n\nToy examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>%\nsemi_join(y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(value)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  value xcol \n  <dbl> <chr>\n1   100 x1   \n2   200 x2   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx %>%\nanti_join(y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(value)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  value xcol \n  <dbl> <chr>\n1   300 x3   \n```\n:::\n:::\n\n\n:::{.callout-note}\nWe can manually specify which columns to **join by** and the columns do not have to have the same name! See the example below.\n:::\n\nCheck out the new data frame `x2`:\n\n::: {.cell}\n\n```{.r .cell-code}\nx2 = x %>%\n  mutate(new_value = value) %>%\n  select(new_value, xcol)\n\nx2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  new_value xcol \n      <dbl> <chr>\n1       100 x1   \n2       200 x2   \n3       300 x3   \n```\n:::\n:::\n\nWe can still join `x2` with `y` but `left_join(x2, y)` won't work. We have to manually specify which columns to join by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx2 %>%\n  left_join(y, by = c(\"new_value\" = \"value\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  new_value xcol  ycol \n      <dbl> <chr> <chr>\n1       100 x1    y1   \n2       200 x2    y2   \n3       300 x3    <NA> \n```\n:::\n:::\n\n\n## Practice\n\nWe'll take a look at some New York flights data.\n\nThis data set contains on-time data for all flights that departed NYC (i.e. JFK, LGA or EWR) in 2013.\n\nThis data is a subset of the data set provided by the `nycflights13` package.\n\n### Codebook\n\n`flights2` contains\n\n- `year`: departure year\n- `time_hour`: departure time\n- `dep_delay`: departure delay in minutes\n- `arr_delay`: arrival delay in minutes\n- `origin`: origin\n- `dest`: destination\n- `carrier` two letter carrier abbreviation\n\n`airlines` contains\n\n- `carrier`: two letter carrier abbrevation\n- `name`: full carrier name\n\n`airports` contains \n\n- `faa`: FAA airport code\n- `name`: name of airport\n- `lat`: latitude\n- `lon`: longitude\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights = read_csv(\"https://sta101-fa22.netlify.app/static/appex/data/flights.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 10000 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (4): origin, dest, tailnum, carrier\ndbl  (3): year, dep_delay, arr_delay\ndttm (1): time_hour\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nairlines = read_csv(\"https://sta101-fa22.netlify.app/static/appex/data/airlines.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 16 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): carrier, name\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nairports = read_csv(\"https://sta101-fa22.netlify.app/static/appex/data/airports.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 1458 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): faa, name\ndbl (2): lat, lon\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n#### Exercise 1\n\n`flights` contains the two letter carrier abbreviations and `airlines` contains a dictionary. It would be nice if this information was in one data frame so we could read off easily e.g. which airlines are most likely to have arrival delays.\n\nUse an appropriate join to add the column of `airlines` to `flights` and save the resulting data frame as `flights2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code here\n```\n:::\n\n#### Exercise 2\n\nUsing `flights2`, report the average arrival delay for each carrier. Print only the 5 carrier airline with the worst arrival delays on average. No joins required here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code here\n```\n:::\n\n\n#### Exercise 3\n\nCreate a new data set called `dest_delays` that reports the median arrival delay at each destination airport.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code here\n```\n:::\n\n\n\n#### Exercise 4\n\nWhich destination has the worst arrival delay? (Note: you will need to join `dest_delays` with `airports` to answer this question)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code here\n```\n:::\n\n\n#### Optional bonus\n\n- Is there anything else you might want to learn from the data before declaring one airport is most likely to have delayed arrival or one carrier is most likely to result in a delayed flight?\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}